#include "stdafx.h"
#include "Hmacsha1.h"
#pragma comment(lib, "sm9Dll.lib")
#include "ibe.h"
#include <iostream>
#include <time.h>
#include <string.h>
using namespace std;
//	const int PBITS = 1024;
const int LEN1 = 4 * PBYTES;
const int LEN2 = 2 * PBYTES;
const int LEN3 = 3 * PBYTES;
CRITICAL_SECTION h_csLock;
char *masterchar = "F402C387388B8C50BDED95D28E8B563CD91D67F3AFF97D04F7431C023E50E247";
char master[2 * QBYTES + 1] = { 0 };  //系统参数
char ibcPara[LEN1] = {						//公共参数，512字节
	0x89,0x92,0xFA,0xE2,0xBA,0x5C,0xB7,0x60,0xAD,0x8B,0x0F,0xA2,0x9A,0x50,0x1A,0x7F,
	0xBB,0x8A,0x6D,0x24,0xBB,0x7A,0x3E,0xB7,0xF8,0x39,0xE5,0x1C,0xB5,0x49,0xF7,0xF5,
	0x64,0xFE,0x99,0x2D,0x3E,0xF9,0x05,0x26,0x01,0x63,0xEF,0xD8,0xBB,0x07,0xB7,0x2F,
	0xE8,0x14,0xAF,0xC5,0x39,0x5B,0x79,0x57,0x96,0xE3,0x3B,0x82,0xA4,0xD9,0x61,0x93,
	0x90,0xC4,0xFF,0xAC,0x3B,0x9E,0x61,0x36,0x0F,0xAF,0x7A,0xB2,0x68,0xEB,0x89,0x16,
	0x9D,0x60,0x4A,0x6D,0x0F,0xD2,0x41,0x2E,0xFE,0xE3,0x87,0x04,0x06,0x27,0xD9,0xE7,
	0x22,0xDF,0x0F,0x14,0x14,0x17,0x69,0x8D,0x5C,0x37,0xB5,0x87,0xF1,0x93,0x0B,0x2F,
	0xDE,0x31,0xEC,0x06,0x21,0xB1,0x65,0xAD,0x27,0x3E,0x65,0x14,0x8C,0xDA,0xB2,0x48,
	0x54,0x8F,0xCE,0x5C,0xE9,0x86,0x12,0xC2,0x5A,0x85,0xCE,0xD7,0x9F,0x87,0x53,0xC1,
	0xC7,0x10,0x0E,0x80,0xC2,0x8A,0xE4,0xA5,0x57,0x50,0xD0,0xB4,0x80,0x92,0xE6,0x0D,
	0x38,0x8C,0x6C,0xBD,0xB7,0xB6,0x47,0x8A,0xEB,0x63,0x5F,0xBA,0xB9,0x6D,0xF9,0x49,
	0x14,0x0F,0x73,0x78,0x90,0x22,0x5A,0x31,0xFA,0x63,0x0D,0x31,0x8F,0x68,0xFA,0x88,
	0xE3,0xF7,0x84,0x7D,0x22,0x40,0x05,0x56,0x96,0x38,0x76,0xDD,0x38,0x3B,0x5A,0x0A,
	0x60,0x35,0xF4,0xE4,0x65,0x14,0xFB,0x57,0x70,0x1C,0x9A,0x96,0x44,0x66,0xF9,0x26,
	0xC4,0xC6,0x3C,0xCF,0x4D,0x2B,0x7A,0xB6,0x63,0x8B,0xAA,0x5C,0x8B,0x40,0x5A,0x70,
	0x42,0xA3,0xAF,0x16,0xFE,0x79,0xC6,0xAA,0xDA,0x45,0x16,0xB0,0xDC,0x93,0x7E,0x84,
	0x99,0x2D,0xE2,0x18,0x60,0x0C,0x82,0xA0,0xA4,0xCD,0x07,0x2D,0x87,0xE1,0x7C,0x9E,
	0x9E,0x70,0x24,0x44,0x65,0x3D,0x99,0xE0,0x2A,0xF2,0x78,0x76,0x73,0xC3,0xFE,0x97,
	0xCA,0x8A,0xF6,0x36,0x5A,0x63,0x0A,0x14,0x0C,0x0F,0x29,0x70,0xAB,0x12,0xAF,0x66,
	0x4E,0x1E,0x8E,0xE7,0x6C,0x9A,0x8F,0xF8,0x01,0xDC,0x75,0x26,0x2D,0x41,0x38,0xE7,
	0x03,0x61,0xA0,0x02,0xA5,0xB4,0x05,0xDC,0x37,0x5E,0x3F,0x64,0x51,0xAE,0x91,0x4C,
	0x91,0xE1,0xEB,0x76,0xB5,0xC2,0x57,0x43,0x95,0x4F,0x17,0x63,0x86,0xBC,0x51,0x01,
	0x97,0x87,0x42,0x21,0x99,0x60,0xBF,0x36,0x6E,0xF1,0xAF,0x27,0xD6,0xB6,0x3F,0x2F,
	0x0B,0x03,0x4D,0x99,0xF0,0xA4,0x1F,0x4C,0xFD,0x9E,0xC4,0x35,0xA7,0x1F,0xF0,0x2D,
	0x0C,0x59,0x2B,0xFF,0xFF,0x8B,0xA2,0xB2,0xDD,0x54,0x9C,0x9A,0xBC,0x05,0xFD,0xA2,
	0x5A,0x66,0x73,0xFD,0xD5,0x2C,0x10,0xE8,0x56,0xEC,0xBD,0xD4,0x4F,0x83,0x43,0x20,
	0x68,0x94,0x67,0x03,0x25,0xC0,0xA9,0x1E,0xFB,0x18,0xC3,0x62,0x7A,0xD1,0xEE,0x06,
	0x24,0x05,0x00,0x1D,0x99,0x1A,0x18,0xE3,0x4A,0x97,0x90,0xE8,0xC8,0xC9,0x9B,0xF2,
	0xEF,0x2B,0x3C,0xAF,0x5B,0x4D,0x17,0x22,0xD6,0x56,0xDA,0x87,0x64,0xF4,0xE8,0x89,
	0x52,0xA3,0xEE,0x47,0x21,0x1E,0x36,0xF1,0xEC,0x53,0xB4,0xF7,0x1B,0xCA,0xDE,0x2A,
	0x6E,0x17,0x90,0xED,0x0F,0x70,0x0C,0xDB,0x1D,0xF4,0x88,0x11,0x81,0xE2,0xD5,0x14,
	0x52,0xA4,0x4D,0xD8,0x9B,0xD1,0xDF,0x62,0xB4,0xA0,0x53,0x8A,0xDF,0x9B,0x2D,0x00 };
/*
char privateKey[LEN2] = {   //256字节,由id字符串公钥所生成的私钥
	0xA7,0x92,0xE5,0x7D,0x77,0xE5,0x81,0xC7,0xA0,0x5B,0x54,0x4E,0x32,0x3A,0x43,0xB0,
	0x2D,0x86,0x73,0xAD,0x89,0x7B,0xF7,0xCC,0x7A,0x6E,0x52,0xC1,0x06,0x71,0x3F,0xD4,
	0xDE,0x5C,0x04,0x4B,0xAA,0x8F,0xD4,0x25,0x96,0x09,0xFC,0x7E,0x47,0x27,0x3F,0x23,
	0xBA,0x67,0x25,0x7C,0xA2,0x21,0xDC,0x72,0x48,0x62,0xC0,0xF0,0x8D,0x65,0x41,0x5A,
	0xF6,0x58,0x7F,0xA2,0xA3,0x7C,0x01,0xF6,0xE2,0xCD,0x44,0x62,0xDF,0x12,0x2D,0xAC,
	0x8B,0x4A,0x6F,0xFF,0x2D,0xD0,0x24,0x64,0x40,0x4C,0x00,0x8A,0x2F,0x30,0x54,0xE6,
	0x66,0x4F,0x43,0xE5,0xD1,0x15,0x84,0xAD,0xA5,0x04,0x40,0xAD,0x9F,0x9C,0x4B,0x86,
	0x05,0x4E,0xBC,0x49,0x16,0x65,0xD5,0x37,0x09,0xA5,0xBC,0x71,0xB7,0x62,0xE0,0x6A,
	0x96,0x70,0x42,0x20,0x44,0xB5,0x5D,0x60,0x7A,0xE6,0xF0,0x4F,0xDB,0xDB,0xC9,0xBA,
	0x82,0x38,0x6B,0x22,0xA4,0x76,0x4F,0x2F,0xB9,0x40,0xF3,0xC8,0x09,0xE2,0xA1,0xF1,
	0x73,0x1C,0x91,0x92,0x3F,0x08,0x0D,0x95,0x5E,0xE5,0x30,0x31,0x4D,0xB4,0xE5,0xAD,
	0x29,0xE8,0x0A,0x82,0x88,0xDF,0x68,0xB2,0x4C,0x53,0x44,0x54,0xEB,0x06,0x36,0xFD,
	0x36,0xE5,0x6F,0xC4,0x74,0x09,0x50,0x16,0x31,0x49,0xE4,0xEF,0x4A,0x03,0x39,0x1E,
	0x35,0xD5,0xCA,0x74,0xEA,0xB6,0x6A,0x03,0x27,0x92,0xF1,0xE7,0xF2,0xD0,0x4E,0x34,
	0xC6,0x58,0x28,0x6D,0x9B,0xF7,0x19,0x22,0x70,0x7A,0xEB,0x2E,0xD5,0x64,0xED,0xBB,
	0xDD,0xA0,0x3C,0x96,0x22,0xED,0x76,0x05,0x73,0x3B,0x07,0x19,0x13,0xDC,0x19,0x90 };
	*/

char * HexToStr(char *szOutStr, size_t szlen, unsigned char *hex, size_t size)
{
	unsigned char ch, shiftch;
	unsigned char * src = hex;
	char * des = szOutStr;

	if (szOutStr == NULL || hex == NULL)
		return NULL;
	//buffer size
	if ((szlen - 1) < size * 2)
		return NULL;
	while (size-- > 0)
	{
		ch = *src++;
		shiftch = ch >> 4;
		if (shiftch >= 0x0 && shiftch <= 0x09)
			*des++ = shiftch + '0';
		if (shiftch >= 0x0a && shiftch <= 0x0f)
			*des++ = shiftch + 0x57;
		shiftch = ch & 0x0f;
		if (shiftch >= 0x0 && shiftch <= 0x09)
			*des++ = shiftch + '0';
		if (shiftch >= 0x0a && shiftch <= 0x0f)
			*des++ = shiftch + 0x57;

	}
	*des = 0;
	return szOutStr;
}
CHmacsha1::CHmacsha1()
{
	InitializeCriticalSection(&h_csLock);
}


CHmacsha1::~CHmacsha1()
{


}

int CHmacsha1::EncodeString(CString szPlaintext, CString& szCiphertext, int& len)
{
	int result;
	int length = 0;
	int length2 = 0;
	CCharacterHelper characterHelper;
	char* cpbPlainText = characterHelper.UnicodeToANSI(szPlaintext);
	len = strlen(cpbPlainText);

	byte* ciphertext = new byte[len + SESSIONKEYLENGTH];
	memset(ciphertext, 0, len + SESSIONKEYLENGTH);
	EnterCriticalSection(&h_csLock);
	result = EncString(ciphertext, &length, (const byte*)cpbPlainText, len, id, ibcPara);
	LeaveCriticalSection(&h_csLock);
	//byte* plaintext = new byte[len + SESSIONKEYLENGTH];
	//memset(plaintext, 0, len + SESSIONKEYLENGTH);
	//result = DecString(plaintext, &length2, (const byte*)ciphertext, length, privateKey, id, ibcPara);
	CBase64Helper Base64Helper;
	int plen = len + SESSIONKEYLENGTH;
	char * base64code = new char[2 * plen + 1];
	memset(base64code, 0, 2 * plen + 1);
	int l=Base64Helper.Base64Encode(base64code, (char*)ciphertext, plen);
	wchar_t* wcszCiphertext = characterHelper.AnsiToUnicode(base64code);
	szCiphertext=wcszCiphertext;
	free(wcszCiphertext);
	free(cpbPlainText);
	delete[] ciphertext;
	ciphertext = NULL;
	delete[] base64code;
	base64code = NULL;
	return result;
}

int CHmacsha1::DecodeString(CString& szPlaintext, CString szCiphertext,int len)
{
	int result;
	int length = 0;
	CCharacterHelper characterHelper;
	char* cszCiphertext = characterHelper.UnicodeToANSI(szCiphertext);
	int pLen = strlen(cszCiphertext);
	CBase64Helper Base64Helper;
	char *Buffer = new char[pLen];
	memset(Buffer, 0, pLen);
	int nlen = Base64Helper.Base64Decode(Buffer, cszCiphertext, pLen);
	
	char *privateKey = new char[265+1];
	memset(privateKey, 0, 256+1);
	Base64Helper.Base64Decode(privateKey, key, strlen(key));

	byte* plaintext = new byte[nlen +1];
	memset(plaintext, 0, nlen +1);
	EnterCriticalSection(&h_csLock);
	result = DecString(plaintext, &length, (const byte*)Buffer, nlen , privateKey, id, ibcPara);
	LeaveCriticalSection(&h_csLock);
	wchar_t* wcszPlaintext = characterHelper.AnsiToUnicode((const char*)plaintext);
	szPlaintext = wcszPlaintext;
	free(cszCiphertext);
	free(wcszPlaintext);
	delete[] Buffer;
	Buffer = NULL;
	delete[] plaintext;
	plaintext = NULL;
	return result;
}

int CHmacsha1::SignatureString(CString& signature, CString szText)
{
	int len = szText.GetLength();
	len += SESSIONKEYLENGTH;
	int result;
	byte usignature[3 * PBYTES] = {0};
	CCharacterHelper characterHelper;
	char* cszText = characterHelper.UnicodeToANSI(szText);
	CBase64Helper Base64Helper;
	char privateKey[257] = { 0 };
	int nkeylen = Base64Helper.Base64Decode(privateKey, key);
	//FILE *fp = fopen("MISIG.txt", "w");
	//fprintf(fp, "\n私钥：%s\n", key);
	//char sss[513] = {0};

	//HexToStr(sss, 513, (byte*)privateKey, 256);
	//fwrite(sss, 1, 512, fp);
	//fprintf(fp, "\n签名数据：%s  len=%d\n", cszText, strlen(cszText));
	//fprintf(fp, "\n公钥：%s\n", pIdentity);
	//char *pxxx = "AAABBBCCCDDD";
	EnterCriticalSection(&h_csLock);
	result = SigString(usignature,(unsigned char*)cszText, strlen(cszText), privateKey, ibcPara);
	LeaveCriticalSection(&h_csLock);
//	int x = VerifyString((unsigned char*)usignature, strlen(cszText), (unsigned char*)cszText, id, ibcPara);
	char * base64code = new char[2 * len + 1];
	memset(base64code, 0, 2 * len + 1);
	wchar_t* wcSignature = new wchar_t[2 * len + 1];
	memset(wcSignature, 0, 2 * len + 1);
	int l = Base64Helper.Base64Encode(base64code, (char*)usignature, sizeof(usignature));
	//fprintf(fp, "\n签名：%s\n", base64code);
	//fclose(fp);
	wcSignature =characterHelper.AnsiToUnicode(base64code);
	//XC_AnsiToUnicode(base64code, strlen(base64code), wcSignature, MAX_SIZE);
	signature = wcSignature;
	free(cszText);
	delete[] base64code;
	base64code = NULL;
	delete[] wcSignature;
	wcSignature = NULL;
	return result;
}

int CHmacsha1::VerifySignatureString(CString signature, CString szText)
{
	int len = szText.GetLength();
	len += SESSIONKEYLENGTH;
	int result;
	CCharacterHelper characterHelper;
	char* cszText = characterHelper.UnicodeToANSI(szText);
	//char * base64code = new char[2 * len + 1];
	//memset(base64code, 0, 2 * len + 1);
	char* base64code = characterHelper.UnicodeToANSI(signature);
	//XC_UnicodeToAnsi(signature, signature.GetLength(), base64code, 2 * len + 1);
	int a = strlen(base64code);
	char *Buffer = new char[a];
	CBase64Helper Base64Helper;
	int nlen = Base64Helper.Base64Decode(Buffer, base64code, a);
	EnterCriticalSection(&h_csLock);
	result = VerifyString((unsigned char*)Buffer, strlen(cszText), (unsigned char*)cszText, id, ibcPara);
	LeaveCriticalSection(&h_csLock);
	free(cszText);
	delete[] base64code;
	base64code = NULL;
	delete[] Buffer;
	Buffer = NULL;
	return result;
}
